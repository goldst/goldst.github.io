'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var table = _interopDefault(require('text-table'));
var stringWidth = _interopDefault(require('string-width'));
var chalk = _interopDefault(require('chalk'));
var redent = _interopDefault(require('redent'));
var path = _interopDefault(require('path'));
var EventEmitter = _interopDefault(require('events'));
var minimost = _interopDefault(require('minimost'));
var readPkg = _interopDefault(require('read-pkg-up'));

class CacError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CacError';
    }
}

function orderNames(names) {
    return names.sort((a, b) => {
        return a.length > b.length ? 1 : -1;
    });
}
function textTable(data) {
    return table(data, {
        stringLength: stringWidth
    });
}
function prefixOption(option) {
    return option.length === 1 ? `-${option}` : `--${option}`;
}
function invariant(exp, message) {
    if (!exp) {
        throw new CacError(message);
    }
}

class Options {
    constructor() {
        this.options = [];
    }
    add(name, opt) {
        let names = [name];
        if (typeof opt === 'string') {
            opt = { desc: opt };
        }
        else if (typeof opt === 'object') {
            names = names.concat(opt.alias || []);
        }
        const option = Object.assign({}, opt, { name, names: orderNames(names) });
        this.options.push(option);
        return this;
    }
    getDefaultsMapping() {
        return this.options
            .filter(option => {
            return typeof option.default !== 'undefined';
        })
            .reduce((res, next) => {
            if (next.default !== undefined) {
                res[next.name] = next.default;
            }
            return res;
        }, {});
    }
    getOptionsByType(type) {
        return this.options.filter(option => type === option.type);
    }
    getOptionNamesByType(type) {
        return this.getOptionsByType(type).map(option => option.name);
    }
    getAliasMap() {
        return this.options.reduce((res, next) => {
            if (next.alias !== undefined) {
                res[next.name] = next.alias;
            }
            return res;
        }, {});
    }
    isEmpty() {
        return this.options.length === 0;
    }
    toString() {
        return textTable(this.options.map(option => {
            const extra = [];
            if (typeof option.default !== 'undefined') {
                extra.push(`Default: ${JSON.stringify(option.default)}`);
            }
            if (typeof option.type === 'string') {
                extra.push(`Type: ${option.type}`);
            }
            return [
                option.names.map(v => chalk.yellow(prefixOption(v))).join(', '),
                chalk.dim(option.desc),
                extra.map(v => chalk.dim(`[${v}]`)).join(' ')
            ];
        }));
    }
}

class Command {
    constructor(name, opt, handler) {
        invariant(typeof name === 'string', 'Expect command name to be a string');
        let names = [name];
        if (typeof opt === 'string') {
            opt = { desc: opt };
        }
        else if (typeof opt === 'object') {
            names = names.concat(opt.alias || []);
        }
        invariant(typeof opt.desc === 'string', 'Expect command description to be a string');
        const command = Object.assign({}, opt, { name, names: orderNames(names) });
        this.command = command;
        this.options = new Options();
        this.handler = handler;
    }
    option(name, opt) {
        this.options.add(name, opt);
        return this;
    }
}

class Help {
    constructor(root, command, opts) {
        this.root = root;
        this.command = command;
        this.opts = opts;
    }
    getHelp() {
        let help = '\n';
        help += chalk.cyan(this.root.bin);
        if (this.root.pkg.version) {
            if (!this.opts.displayCommands && this.command) {
                help += ` ${this.command.command.name}`;
            }
            help += ` ${this.root.pkg.version}`;
        }
        help += '\n\n';
        if (!this.opts.displayCommands && this.command) {
            help += `${chalk.dim.italic(this.command.command.desc)}\n\n`;
        }
        else if (this.root.pkg.description) {
            help += `${chalk.dim.italic(this.root.pkg.description)}\n\n`;
        }
        const commandText = this.command
            ? chalk.magenta(this.opts.displayCommands
                ? '<command> '
                : `${this.command.command.name} `)
            : '';
        help += `${chalk.bold('USAGE')}\n\n`;
        help += redent(`${chalk.dim.italic(this.root.bin)} ${commandText}${chalk.yellow('[options]')}`, 2);
        help += '\n\n';
        if (this.opts.displayCommands && !this.root.isCommandsEmpty()) {
            help += formatSection({
                title: 'COMMANDS',
                body: this.root.commandsToString()
            });
        }
        if (!this.opts.displayCommands && this.command && !this.command.options.isEmpty()) {
            help += formatSection({
                title: 'COMMAND OPTIONS',
                body: this.command.options.toString()
            });
        }
        if (!this.root.options.isEmpty()) {
            help += formatSection({
                title: 'GLOBAL OPTIONS',
                body: this.root.options.toString()
            });
        }
        for (const h of this.root.extraHelps) {
            help += formatSection(h);
        }
        return redent(help, 2);
    }
    output() {
        process.stdout.write(this.getHelp());
        return this;
    }
}
function formatSection(sec) {
    if (typeof sec === 'string') {
        return sec;
    }
    const { title, body } = sec;
    return `${title ? `${chalk.bold(title)}\n\n` : ''}${redent(body.trim(), 2)}\n\n`;
}

var examplesPlugin = () => (cli) => {
    cli.on('parsed', command => {
        if (command && command.command.examples) {
            cli.extraHelp({
                title: 'EXAMPLES',
                body: command.command.examples.join('\n')
            });
        }
    });
};

var optionChoicesPlugin = () => (cli) => {
    cli.on('parsed', (command, _, flags) => {
        if (!command)
            return;
        const failedOptions = command.options.options.filter((option) => {
            const shouldCheck = option.choices && typeof flags[option.name] !== 'undefined';
            const isOneOfChices = option.choices &&
                option.choices.filter((choice) => {
                    return choice === flags[option.name];
                }).length > 0;
            return Boolean(shouldCheck && !isOneOfChices);
        });
        if (failedOptions.length > 0) {
            for (const option of failedOptions) {
                console.log(`The value of flag "${option.name}" should be one of: ${option.choices.map((choice) => `"${choice}"`)}`);
            }
            process.exit(1); // eslint-disable-line unicorn/no-process-exit
        }
    });
};

var requiredOptionPlugin = () => (cli) => {
    cli.on('parsed', (command, _, flags) => {
        if (!command)
            return;
        const missingRequiredOptions = command.options.options.filter(option => {
            const isRequired = option.required;
            const isMissing = typeof flags[option.name] === 'undefined';
            return isMissing && isRequired;
        });
        if (missingRequiredOptions.length > 0) {
            console.log(`Missing options: ${missingRequiredOptions
                .map(option => option.name)
                .join(', ')}`);
            process.exit(1); // eslint-disable-line unicorn/no-process-exit
        }
    });
};

// Prevent caching of this module so module.parent is always accurate
delete require.cache[__filename];
let parentDir;
if (module.parent && module.parent.filename) {
    parentDir = path.dirname(module.parent.filename);
}
else {
    parentDir = process.cwd();
}
class Cac extends EventEmitter {
    constructor({ bin, pkg, defaultOpts } = {}) {
        super();
        defaultOpts = defaultOpts || true;
        this.bin = bin || path.basename(process.argv[1]);
        this.commands = [];
        this.options = new Options();
        this.extraHelps = [];
        if (typeof defaultOpts === 'boolean') {
            this.helpOpt = defaultOpts;
            this.versionOpt = defaultOpts;
        }
        else if (typeof defaultOpts === 'object') {
            this.helpOpt = defaultOpts.help !== false;
            this.versionOpt = defaultOpts.version !== false;
        }
        this.pkg = Object.assign({}, pkg || readPkg.sync({ cwd: parentDir, normalize: false }).pkg);
        if (this.versionOpt) {
            this.option('version', {
                desc: 'Display version',
                alias: 'v',
                type: 'boolean'
            });
        }
        if (this.helpOpt) {
            this.option('help', {
                desc: `Display help (You're already here)`,
                alias: 'h',
                type: 'boolean'
            });
        }
        this.use(examplesPlugin());
        this.use(optionChoicesPlugin());
        this.use(requiredOptionPlugin());
    }
    /**
     * Use a plugin or an array of plugins
     */
    use(plugin) {
        if (Array.isArray(plugin)) {
            plugin.forEach(p => this.use(p));
        }
        else if (typeof plugin === 'function') {
            plugin(this);
        }
        else {
            throw new TypeError('plugin has to be a function or an array of it.');
        }
        return this;
    }
    /**
     * Add a global option
     */
    option(name, opt) {
        this.options.add(name, opt);
        return this;
    }
    /**
     * Add a sub command
     */
    command(name, opt, handler) {
        const command = new Command(name, opt, handler);
        this.commands.push(command);
        return command;
    }
    /**
     * Commands to string
     *
     * Used to display help
     */
    commandsToString() {
        return textTable(this.commands.map(({ command }) => {
            return [
                command.names.map(v => chalk.magenta(v)).join(', '),
                chalk.dim(command.desc)
            ];
        }));
    }
    /**
     * Check if there's any command
     */
    isCommandsEmpty() {
        return this.commands.length === 0;
    }
    /**
     * Find command by command name, alias or addtionalMatch
     */
    findCommand(name) {
        // Try to find command by command name
        for (const command of this.commands) {
            const { names, match } = command.command;
            if (names.includes(name)) {
                return { command, sliceFirstArg: Boolean(name && name !== '*') };
            }
            if (match && match(name)) {
                return { command, sliceFirstArg: false };
            }
        }
        return {
            command: name === '*' ? null : this.findCommand('*').command,
            sliceFirstArg: false
        };
    }
    get argv() {
        return this.parse(null, { run: false });
    }
    showHelp() {
        if (!this.started) {
            throw new Error('[cac] You have to call .parse() before running .showHelp()');
        }
        // Do not display `<command>` in help if it's a sub command
        // This matches a sub command
        const displayCommands = this.commandName === '*';
        const help = new Help(this, this.matchedCommand, {
            displayCommands
        });
        help.output();
        return this;
    }
    /**
     * Show version in console
     */
    showVersion() {
        console.log(this.pkg.version);
    }
    /**
     * Add an extra help message
     */
    extraHelp(help) {
        this.extraHelps.push(help);
        return this;
    }
    /**
     * Parse CLI argument and run commands
     * @param argv Default to `process.argv.slice(2)`
     * @param opts
     */
    parse(argv, opts = {}) {
        const { run = true, showHelp } = opts;
        this.started = true;
        argv = argv || process.argv.slice(2);
        // Ensure that command name is not a flag
        if (argv[0] && !argv[0].startsWith('-')) {
            this.commandName = argv[0];
        }
        else {
            this.commandName = '*';
        }
        const { command, sliceFirstArg } = this.findCommand(this.commandName);
        this.matchedCommand = command;
        let { input, flags } = minimost(argv, {
            boolean: [
                ...this.options.getOptionNamesByType('boolean'),
                ...(command ? command.options.getOptionNamesByType('boolean') : [])
            ],
            string: [
                ...this.options.getOptionNamesByType('string'),
                ...(command ? command.options.getOptionNamesByType('string') : [])
            ],
            default: Object.assign({}, this.options.getDefaultsMapping(), (command ? command.options.getDefaultsMapping() : [])),
            alias: Object.assign({}, this.options.getAliasMap(), (command ? command.options.getAliasMap() : {}))
        });
        input = sliceFirstArg ? input.slice(1) : input;
        this.emit('parsed', command, input, flags);
        if (!run) {
            return { input, flags };
        }
        const shouldShowHelp = showHelp || (() => Boolean(this.helpOpt && flags.help));
        if (shouldShowHelp(command, input, flags)) {
            this.showHelp();
        }
        else if (this.versionOpt && flags.version) {
            this.showVersion();
        }
        else if (command && command.handler) {
            try {
                let res = command.handler(input, flags);
                if (res && res.then) {
                    res.then(() => {
                        this.emit('executed', command, input, flags);
                    }).catch((err) => this.handleError(err));
                }
                else {
                    this.emit('executed', command, input, flags);
                }
            }
            catch (err) {
                this.handleError(err);
            }
        }
        return { input, flags };
    }
    handleError(err) {
        if (this.listenerCount('error') === 0) {
            console.error(err.stack);
            process.exitCode = process.exitCode || 1;
        }
        else {
            this.emit('error', err);
        }
    }
}

/// <reference path="../declarations.d.ts" />
function cac(opts) {
    return new Cac(opts);
}
(function (cac) {
    function parse(args, opts) {
        return minimost(args, opts);
    }
    cac.parse = parse;
})(cac || (cac = {}));
var cac$1 = cac;
// For CommonJS default export support
module.exports = cac;
module.exports.default = cac;
module.exports.Cac = Cac;

exports.default = cac$1;
exports.Cac = Cac;
